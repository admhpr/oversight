__NUXT_JSONP__("/", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT,bU,bV,bW,bX,bY,bZ,b_,b$,ca,cb,cc,cd,ce,cf,cg,ch,ci,cj,ck,cl,cm,cn,co,cp,cq,cr,cs,ct,cu,cv,cw,cx,cy,cz,cA,cB,cC,cD,cE,cF,cG,cH,cI,cJ,cK,cL,cM,cN,cO,cP,cQ,cR,cS,cT,cU,cV,cW,cX,cY,cZ,c_,c$,da,db,dc,dd,de,df,dg,dh,di,dj,dk,dl,dm,dn,do_,dp,dq,dr,ds,dt,du,dv,dw,dx,dy,dz,dA,dB,dC,dD,dE,dF,dG,dH,dI,dJ,dK,dL,dM,dN,dO,dP,dQ,dR,dS,dT,dU,dV,dW,dX,dY,dZ,d_,d$,ea,eb,ec,ed,ee,ef,eg,eh,ei,ej,ek,el,em,en,eo,ep,eq,er,es,et,eu,ev,ew,ex,ey,ez,eA,eB,eC,eD,eE,eF,eG,eH,eI,eJ,eK,eL){return {data:[{posts:[{slug:"lists-list-more-lists",title:ca,date:"2021-12-13T06:52",desc:cb,tags:[aN,"data structures"],toc:[{id:cc,depth:aC,text:cd},{id:ce,depth:U,text:cf},{id:cg,depth:U,text:ch},{id:ci,depth:U,text:cj},{id:ck,depth:aC,text:cl},{id:cm,depth:aC,text:cn}],body:{type:aH,children:[{type:b,tag:j,props:{},children:[{type:a,value:cb}]},{type:a,value:f},{type:b,tag:aD,props:{id:cc},children:[{type:b,tag:C,props:{href:"#linked-lists",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cd}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:bE},{type:b,tag:C,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FLinked_list#Singly_linked_list",rel:[ab,ac,ad],target:ae},children:[{type:a,value:ca}]},{type:a,value:" stores entries in sequence pointing to next item in the chain. When there is the no next item the pointer points to some form of nothing, such as "},{type:b,tag:i,props:{},children:[{type:a,value:"nil\u002Fnull\u002FNone"}]},{type:a,value:" etc."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[aj,z]},children:[{type:b,tag:i,props:{},children:[{type:a,value:"+--------+  +-------+  +-------+  +-------+\n"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" LENGTH "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:co},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:co},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" HEAD   +--"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"    +-------+\n+--------+  +---------"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:cp},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:cq},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:"+ NULL  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" TAIL   "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:bF},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:bF},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:bF},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"    +-------+\n+--------+  +-------+  +-------+  +-------+\n         +------------------------------^\n\n"}]}]}]},{type:a,value:f},{type:b,tag:V,props:{id:ce},children:[{type:b,tag:C,props:{href:"#example",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cf}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"A potential use case for a singly linked list would be a "},{type:b,tag:C,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTransaction_log",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"transaction log"}]},{type:a,value:", this an append only list where commands ( such as a SQL statement ) are added to a list before being written to persistent storage."}]},{type:a,value:f},{type:b,tag:V,props:{id:cg},children:[{type:b,tag:C,props:{href:"#pros",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:ch}]},{type:a,value:f},{type:b,tag:V,props:{id:ci},children:[{type:b,tag:C,props:{href:"#cons",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cj}]},{type:a,value:f},{type:b,tag:aD,props:{id:ck},children:[{type:b,tag:C,props:{href:"#doubly-linked-lists",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cl}]},{type:a,value:f},{type:b,tag:aD,props:{id:cm},children:[{type:b,tag:C,props:{href:"#skip-lists",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cn}]}]},dir:aI,path:"\u002Fblog\u002Flists-list-more-lists",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"rust-control-flow",title:"control flow in rust",date:"2020-12-27T06:11",desc:ba,tags:[aN],toc:[{id:cr,depth:U,text:cs},{id:ct,depth:U,text:cu},{id:cv,depth:U,text:cw},{id:cx,depth:U,text:cy},{id:cz,depth:U,text:cA},{id:cB,depth:U,text:cC},{id:cD,depth:U,text:cE}],body:{type:aH,children:[{type:b,tag:j,props:{},children:[{type:a,value:"Deciding what piece of code to run based on a whether a condition is met or not is the essence of control flow in code. The most common of which in most languages (including Rust) are "},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:" expressions and "},{type:b,tag:i,props:{},children:[{type:a,value:"loops"}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:V,props:{id:cr},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#if-expressions",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cs}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An "},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:" expression allows you to branch your code depending on conditions. You provide a condition and then state, “If this condition is met, run this block of code. If the condition is not met, do not run this block of code.”"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:cF}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"condition was true\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aE}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"condition was false\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The above snippet is pretty self explanatory, if the number is less than "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:" it prints \"condition was true\" and if the number is greater than 5 it \"condition was false\"."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Optionally, we can also include an "},{type:b,tag:i,props:{},children:[{type:a,value:aE}]},{type:a,value:" expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to false. If you don’t provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Note that the expression being checked in the "},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:" expression must be of type "},{type:b,tag:i,props:{},children:[{type:a,value:cG}]},{type:a,value:". Rust will not automatically try to convert non-Boolean types to a Boolean."}]},{type:a,value:f},{type:b,tag:V,props:{id:ct},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#handling-multiple-conditions-with-else-if",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cu}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You can have multiple conditions by combining "},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:aR},{type:b,tag:i,props:{},children:[{type:a,value:aE}]},{type:a,value:" in an "},{type:b,tag:i,props:{},children:[{type:a,value:"else if"}]},{type:a,value:" expression. For example:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bn}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bo}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"number is divisible by 4\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aE}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bn}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bo}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"number is divisible by 3\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aE}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bn}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bo}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"number is divisible by 2\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aE}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"number is not divisible by 4, 3, or 2\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:V,props:{id:cv},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#using-if-in-a-let-statement",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cw}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Because if is an expression, we can use it on the right side of a "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" statement."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:cH},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bb]},children:[{type:a,value:G}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:cH},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aE}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"The value of number is: {}\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:bG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The value options provided in the "},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:" expression must be of the same type, or the compiler will throw an error. Rust needs to know at compile time what type the number variable is and cannot do that if the value of "},{type:b,tag:i,props:{},children:[{type:a,value:l}]},{type:a,value:" is determined at runtime."}]},{type:a,value:f},{type:b,tag:V,props:{id:cx},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#repetition-with-loops",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cy}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"It’s often useful to execute a block of code more than once. For this task, Rust provides several loops. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust has three kinds of loops: "},{type:b,tag:i,props:{},children:[{type:a,value:aS}]},{type:a,value:aK},{type:b,tag:i,props:{},children:[{type:a,value:bc}]},{type:a,value:bp},{type:b,tag:i,props:{},children:[{type:a,value:bd}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:"h4",props:{id:"repeating-code-with-loop"},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#repeating-code-with-loop",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:"Repeating Code with loop"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:bH},{type:b,tag:i,props:{},children:[{type:a,value:aS}]},{type:a,value:" keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aS}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"again!\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When we run this program, we’ll see "},{type:b,tag:i,props:{},children:[{type:a,value:"again!"}]},{type:a,value:" printed over and over continuously until we stop the program manually (using "},{type:b,tag:i,props:{},children:[{type:a,value:"ctrl-c"}]},{type:a,value:" to interrupt at the terminal)."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Fortunately, Rust provides another, more reliable way to break out of a loop. You can place the "},{type:b,tag:i,props:{},children:[{type:a,value:aT}]},{type:a,value:" keyword within the loop to tell the program when to stop executing the loop."}]},{type:a,value:f},{type:b,tag:V,props:{id:cz},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#returning-values-from-loops",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cA}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:cI},{type:b,tag:i,props:{},children:[{type:a,value:aT}]},{type:a,value:", stopping the loop."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ay}]},{type:a,value:bI},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" result "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aS}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:"\n        counter "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:cJ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:bJ},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:bI},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bo}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aP}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:"\n            "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:aT}]},{type:a,value:bI},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"The result is {}\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:" result"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Before the loop, we declare a variable named counter and initialize it to "},{type:b,tag:i,props:{},children:[{type:a,value:ax}]},{type:a,value:". Then we declare a variable named "},{type:b,tag:i,props:{},children:[{type:a,value:cK}]},{type:a,value:" to hold the value returned from the loop. On every iteration of the loop, we add "},{type:b,tag:i,props:{},children:[{type:a,value:Y}]},{type:a,value:" to the counter variable, and then check whether the counter is equal to "},{type:b,tag:i,props:{},children:[{type:a,value:aP}]},{type:a,value:". When it is, we use the break keyword with the value "},{type:b,tag:i,props:{},children:[{type:a,value:"counter * 2"}]},{type:a,value:". After the loop, we use a semicolon to end the statement that assigns the value to result. Finally, we print the value in "},{type:b,tag:i,props:{},children:[{type:a,value:cK}]},{type:a,value:", which in this case is 20."}]},{type:a,value:f},{type:b,tag:V,props:{id:cB},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#conditional-loops-with-while",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cC}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:cI},{type:b,tag:i,props:{},children:[{type:a,value:aT}]},{type:a,value:", stopping the loop. This loop type could be implemented using a combination of "},{type:b,tag:i,props:{},children:[{type:a,value:aS}]},{type:a,value:aK},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:aK},{type:b,tag:i,props:{},children:[{type:a,value:aE}]},{type:a,value:bp},{type:b,tag:i,props:{},children:[{type:a,value:aT}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"However, this pattern is so common that Rust has a built-in language construct for it, called a "},{type:b,tag:i,props:{},children:[{type:a,value:bc}]},{type:a,value:" loop."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ay}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bc}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"!="}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:cL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:bG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:"\n\n        number "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"-="}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:cM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:cN},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This construct eliminates a lot of nesting that would be necessary if you used "},{type:b,tag:i,props:{},children:[{type:a,value:aS}]},{type:a,value:aK},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:aK},{type:b,tag:i,props:{},children:[{type:a,value:aE}]},{type:a,value:bp},{type:b,tag:i,props:{},children:[{type:a,value:aT}]},{type:a,value:", and it’s clearer. While a condition holds true, the code runs; otherwise, it exits the loop."}]},{type:a,value:f},{type:b,tag:V,props:{id:cD},children:[{type:b,tag:C,props:{ariaHidden:G,href:"#looping-through-a-collection-with-for",tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cE}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You could use the "},{type:b,tag:i,props:{},children:[{type:a,value:bc}]},{type:a,value:" construct to loop over the elements of a collection, such as an array."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:cO}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:cP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:cQ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ay}]},{type:a,value:bM},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bc}]},{type:a,value:bM},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:cF}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:cR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:bN},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:"\n\n        index "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:cJ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Here, the code counts up through the elements in the array. It starts at index "},{type:b,tag:i,props:{},children:[{type:a,value:ax}]},{type:a,value:", and then loops until it reaches the final index in the array (that is, when "},{type:b,tag:i,props:{},children:[{type:a,value:"index \u003C 5"}]},{type:a,value:" is no longer true)."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This approach is error prone; we could cause the program to panic if the index length is incorrect. It’s also slow, because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As a more concise alternative, you can use a "},{type:b,tag:i,props:{},children:[{type:a,value:bd}]},{type:a,value:" loop and execute some code for each item in a collection."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:cO}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:cP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:cQ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bd}]},{type:a,value:bO},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bq}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"iter"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:cR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:cS},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The safety and conciseness of for loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a while loop."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Here’s what the countdown would look like using a "},{type:b,tag:i,props:{},children:[{type:a,value:bd}]},{type:a,value:" loop and "},{type:b,tag:i,props:{},children:[{type:a,value:cT}]},{type:a,value:", to reverse the range:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bd}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bq}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:".."}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:cT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:cL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:bG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:cM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:cN},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:a,value:f}]}]}]}]},dir:aI,path:"\u002Fblog\u002Frust-control-flow",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"rust-data-types",title:"data types in rust",date:"2020-12-15T06:02",desc:ba,tags:[aN],toc:[{id:cU,depth:aC,text:cV},{id:cW,depth:aC,text:cX},{id:cY,depth:U,text:cZ},{id:c_,depth:U,text:c$},{id:da,depth:U,text:db},{id:dc,depth:U,text:dd},{id:bb,depth:U,text:de},{id:df,depth:U,text:dg},{id:dh,depth:aC,text:di},{id:dj,depth:U,text:dk},{id:dl,depth:U,text:dm},{id:dn,depth:U,text:do_},{id:dp,depth:U,text:dq}],body:{type:aH,children:[{type:b,tag:aD,props:{id:cU},children:[{type:b,tag:C,props:{href:"#data-types",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cV}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Every value in Rust has a data type. This piece of additional information let's Rust know how to work with the data."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust is "},{type:b,tag:C,props:{href:"https:\u002F\u002Fwww.techopedia.com\u002Fdefinition\u002F22321\u002Fstatically-typed",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"statically typed"}]},{type:a,value:", meaning that it must know all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Sometimes there are cases where the value can be parsed from a say a string to a number and therefore there could be potentially a number of types associated with that value. In those cases type annotation is important."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" meaning_of_life"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:dr}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:ds}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"parse"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"expect"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dt}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Without type annotation Rust will display the following:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:"$ cargo build\n   Compiling no_type_annotations v0.1.0 "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"file:\u002F\u002F\u002Fprojects\u002Fno_type_annotations"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:"E0282"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:": "},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:bP}]},{type:a,value:" annotations needed\n --"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:2:9\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:a,value:" meaning_of_life "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:ds}]},{type:a,value:".parse"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:".expect"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dt}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"         ^^^^^ consider giving "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"meaning_of_life"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:bP}]},{type:a,value:du},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:bf}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"rustc --explain E0282"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"no_type_annotations"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:aX}]},{type:a,value:dv}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Here, the compiler is letting us know it needs more information on the intended data type of the parsed string."}]},{type:a,value:f},{type:b,tag:aD,props:{id:cW},children:[{type:b,tag:C,props:{href:"#scalar-types",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cX}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:bE},{type:b,tag:C,props:{href:"https:\u002F\u002Fwww.techopedia.com\u002Fdefinition\u002F16441\u002Fscalar",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"scalar"}]},{type:a,value:" type represents a single value. Rust has four primary scalar types:"}]},{type:a,value:f},{type:b,tag:bi,props:{},children:[{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"integars"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"floating-point numbers"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"Booleans"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"characters"}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"These are pretty common across programming languages, here is a quick refresher:"}]},{type:a,value:f},{type:b,tag:V,props:{id:cY},children:[{type:b,tag:C,props:{href:"#integer",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:cZ}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An integer is a number without a fractional component. The table below shows the built-in integer types in Rust. Each variant in the "},{type:b,tag:C,props:{href:"https:\u002F\u002Fwww.ibm.com\u002Fsupport\u002Fknowledgecenter\u002Fssw_aix_72\u002Fcommprogramming\u002Fint_dat_typ.html",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"Signed and Unsigned"}]},{type:a,value:" columns (for example, i16) can be used to declare the type of an integer value. Below are examples of integer types in Rust."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" length "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" signed "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" unsigned "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:dw},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:dw},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:cp},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:dx}]},{type:a,value:"-bit  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" i8     "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" u8       "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"16"}]},{type:a,value:bQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" i16    "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" u16      "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"32"}]},{type:a,value:bQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" i32    "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" u32      "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"64"}]},{type:a,value:bQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" i64    "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" u128     "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" arch   "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" isize  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" usize    "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The isize and usize types depend on the kind of computer your program is running on: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit architecture"}]},{type:a,value:f},{type:b,tag:V,props:{id:c_},children:[{type:b,tag:C,props:{href:"#integer-literals",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:c$}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You can write integers in any of the forms outlined below"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" number literals "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" example    "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"-----------------"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:cq},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" decimal         "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" 78_678     "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" hex             "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" 0xff       "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" octal           "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" 0o77       "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" binary          "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" 0b1111_0000"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" byte "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"u8 only"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" b"},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"'A'"}]},{type:a,value:az},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust defaults integers to "},{type:b,tag:i,props:{},children:[{type:a,value:av}]},{type:a,value:" (which will cover the majority of cases), this type is generally the fastest, even on 64-bit systems. The primary situation in which you’d use "},{type:b,tag:i,props:{},children:[{type:a,value:"isize"}]},{type:a,value:br},{type:b,tag:i,props:{},children:[{type:a,value:dy}]},{type:a,value:" is when indexing some sort of collection."}]},{type:a,value:f},{type:b,tag:V,props:{id:da},children:[{type:b,tag:C,props:{href:"#floating-point-types",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:db}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust also has two primitive types for floating-point numbers, which are numbers with decimal points. Rust’s floating-point types are "},{type:b,tag:i,props:{},children:[{type:a,value:bR}]},{type:a,value:aR},{type:b,tag:i,props:{},children:[{type:a,value:bS}]},{type:a,value:", which are 32 bits and 64 bits in size, respectively. The default type is f64 because on modern CPUs it’s roughly the same speed as "},{type:b,tag:i,props:{},children:[{type:a,value:bR}]},{type:a,value:" but is capable of more precision."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Here’s an example that shows floating-point numbers in action:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"2.0"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F f64"}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bR}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"3.0"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F f32"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Floating-point numbers are represented according to the "},{type:b,tag:C,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FIEEE_754",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"IEEE-754 standard"}]},{type:a,value:". The f32 type is a single-precision float, and f64 has double precision."}]},{type:a,value:f},{type:b,tag:V,props:{id:dc},children:[{type:b,tag:C,props:{href:"#numeric-operations",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dd}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust supports the basic mathematical operations you’d expect for all of the number types: addition, subtraction, multiplication, division, and remainder. The following code shows how you’d use each one in a let statement:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F addition"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" sum "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bj}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F subtraction"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" difference "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"95.5"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"-"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"4.3"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F multiplication"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" product "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F division"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" quotient "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"56.7"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"\u002F"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"32.2"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F remainder"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" remainder "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"43"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bn}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Each expression in these statements uses a mathematical operator and evaluates to a single value, which is then bound to a variable. See "},{type:b,tag:C,props:{href:"https:\u002F\u002Fdoc.rust-lang.org\u002Fstable\u002Fbook\u002Fappendix-02-operators.html",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"here"}]},{type:a,value:" for a full list of operators."}]},{type:a,value:f},{type:b,tag:V,props:{id:bb},children:[{type:b,tag:C,props:{href:"#boolean",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:de}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As in most other programming languages, a Boolean type in Rust has two possible values: true and false. Booleans are one byte in size. The Boolean type in Rust is specified using bool. For example:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" t "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bb]},children:[{type:a,value:G}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" f"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:cG}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bb]},children:[{type:a,value:"false"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F with explicit type annotation"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Boolean types are typically used in control flows such as "},{type:b,tag:i,props:{},children:[{type:a,value:am}]},{type:a,value:" statements."}]},{type:a,value:f},{type:b,tag:V,props:{id:df},children:[{type:b,tag:C,props:{href:"#character-type",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dg}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust’s "},{type:b,tag:i,props:{},children:[{type:a,value:bs}]},{type:a,value:" type is the language’s most primitive alphabetic type, and the following code shows one way to use it. (Note that char literals are specified with single quotes, as opposed to string literals, which use double quotes.)"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" c "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bs,u]},children:[{type:a,value:"'z'"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" z "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bs,u]},children:[{type:a,value:"'ℤ'"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" heart_eyed_cat "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:" '😻'"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Ru jst’s "},{type:b,tag:i,props:{},children:[{type:a,value:bs}]},{type:a,value:" type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust. Unicode Scalar Values range from "},{type:b,tag:i,props:{},children:[{type:a,value:"U+0000"}]},{type:a,value:bt},{type:b,tag:i,props:{},children:[{type:a,value:"U+D7FF"}]},{type:a,value:aR},{type:b,tag:i,props:{},children:[{type:a,value:"U+E000"}]},{type:a,value:bt},{type:b,tag:i,props:{},children:[{type:a,value:"U+10FFFF"}]},{type:a,value:" inclusive. However, a “character” isn’t really a concept in Unicode, so your human intuition for what a “character” is may not match up with what a char is in Rust."}]},{type:a,value:f},{type:b,tag:aD,props:{id:dh},children:[{type:b,tag:C,props:{href:"#compound-types",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:di}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays."}]},{type:a,value:f},{type:b,tag:V,props:{id:dj},children:[{type:b,tag:C,props:{href:"#tuple-type",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dk}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same. We’ve added optional type annotations in this example:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:dz},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bS}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:dA}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bu}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The variable tup binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" tup "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bu}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:" z"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:dz},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:bU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"output:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:"The value of y is: "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bu}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This program first creates a tuple and binds it to the variable "},{type:b,tag:i,props:{},children:[{type:a,value:"tup"}]},{type:a,value:". It then uses a pattern with let to take tup and turn it into three separate variables, "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:aK},{type:b,tag:i,props:{},children:[{type:a,value:bv}]},{type:a,value:bp},{type:b,tag:i,props:{},children:[{type:a,value:"z"}]},{type:a,value:". This is called "},{type:b,tag:aL,props:{},children:[{type:a,value:"destructuring"}]},{type:a,value:", because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bS}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:dA}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bu}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" five_hundred "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:".0"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" six_point_four "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:".1"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" one "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:".2"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This program creates a tuple, "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:", and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0."}]},{type:a,value:f},{type:b,tag:V,props:{id:dl},children:[{type:b,tag:C,props:{href:"#array-type",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dm}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Another way to collect values is an array. Every element in an array must be of the same type (unlike a tuple)."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Arrays in Rust are different from arrays in other languages because arrays have a fixed length, like tuples."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Values going into an array are written as a comma-separated list inside square brackets:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Arrays are useful when data is to stored on the stack rather than the heap ("},{type:b,tag:C,props:{href:"https:\u002F\u002Fmedium.com\u002F@nickolasteixeira\u002Fstack-vs-heap-whats-the-difference-and-why-should-i-care-5abc78da1a88",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"more on stack and heap"}]},{type:a,value:") or when you want to ensure you always have a fixed number of elements.  An array isn’t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size. If you’re unsure whether to use an array or a vector, you should probably use a vector. I will look at vectors in a future post."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It’s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 elements:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" months "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dC}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dH}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:dI},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dJ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dK}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dN}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You would write an array’s type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" months"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:dO}]},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:dP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bV}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dC}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dH}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:dI},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dJ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dK}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:dN}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Writing an array’s type this way looks similar to an alternative syntax for initializing an array: if you want to create an array that contains the same value for each element, you can specify the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The array named "},{type:b,tag:i,props:{},children:[{type:a,value:C}]},{type:a,value:" will contain "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:" elements that will all be set to the value "},{type:b,tag:i,props:{},children:[{type:a,value:ag}]},{type:a,value:" initially. This is the same as writing "},{type:b,tag:i,props:{},children:[{type:a,value:"let a = [3, 3, 3, 3, 3];"}]},{type:a,value:" but in a more concise way."}]},{type:a,value:f},{type:b,tag:V,props:{id:dn},children:[{type:b,tag:C,props:{href:"#accessing-array-elements",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:do_}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" first "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:" second "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In this example, the variable named "},{type:b,tag:i,props:{},children:[{type:a,value:"first"}]},{type:a,value:" will get the value "},{type:b,tag:i,props:{},children:[{type:a,value:Y}]},{type:a,value:", because that is the value at index "},{type:b,tag:i,props:{},children:[{type:a,value:"[0]"}]},{type:a,value:" in the array. The variable named second will get the value "},{type:b,tag:i,props:{},children:[{type:a,value:ak}]},{type:a,value:" from index "},{type:b,tag:i,props:{},children:[{type:a,value:"[1]"}]},{type:a,value:" in the array."}]},{type:a,value:f},{type:b,tag:V,props:{id:dp},children:[{type:b,tag:C,props:{href:"#invalid-array-element-access",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dq}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bM},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aP}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bO},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:bN},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"The value of element is: {}\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:cS},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Running this code using "},{type:b,tag:i,props:{},children:[{type:a,value:"cargo run"}]},{type:a,value:" produces the following result:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:"$ cargo run\n   Compiling arrays v0.1.0 "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"file:\u002F\u002F\u002Fprojects\u002Farrays"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"\nerror: this operation will panic at runtime\n --"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:5:19\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:a,value:bO},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:bN},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"                   ^^^^^^^^ index out of bounds: the len is "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:" but the index is "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aP}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:" note: "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"#[deny(unconditional_panic)]"}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:" on by default\n\nerror: aborting due to previous error\n\nerror: could not compile "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"arrays"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:aX}]},{type:a,value:bw}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The compilation didn’t produce any errors, but the program resulted in a "},{type:b,tag:aL,props:{},children:[{type:a,value:"runtime"}]},{type:a,value:" error and didn’t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you’ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This is the an example of Rust’s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed, which can lead to a number or issues like a "},{type:b,tag:C,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBuffer_overflow",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"buffer overflow"}]},{type:a,value:W}]}]},dir:aI,path:"\u002Fblog\u002Frust-data-types",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"rust-functions",title:"functions in rust",date:"2020-12-19T07:02",desc:ba,tags:[aN],toc:[{id:dQ,depth:U,text:dR},{id:dS,depth:U,text:dT},{id:dU,depth:U,text:dV}],body:{type:aH,children:[{type:b,tag:j,props:{},children:[{type:a,value:"Functions are everywhere in Rust code. The most important function in the language is a function called "},{type:b,tag:i,props:{},children:[{type:a,value:M}]},{type:a,value:", which is the entry to many programs. Another key word to take note of is the "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" keyword, which is a way to declare new functions."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust uses "},{type:b,tag:C,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FSnake_case",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"snake case"}]},{type:a,value:" as the convention in function and variable names. Quick example of a couple of functions including "},{type:b,tag:i,props:{},children:[{type:a,value:M}]},{type:a,value:au}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"Hello, world!\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"Another function.\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Function definitions in Rust start with fn and have a set of parentheses after the function name. The curly brackets tell the compiler where the function body begins and ends."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"We can call any function we’ve defined by entering its name followed by a set of parentheses. Because "},{type:b,tag:i,props:{},children:[{type:a,value:aG}]},{type:a,value:" is defined in the program, it can be called from inside the "},{type:b,tag:i,props:{},children:[{type:a,value:M}]},{type:a,value:" function. Note that we defined "},{type:b,tag:i,props:{},children:[{type:a,value:aG}]},{type:a,value:" after the "},{type:b,tag:i,props:{},children:[{type:a,value:M}]},{type:a,value:" function in the source code; we could have defined it before as well. Rust doesn’t care where you define your functions, only that they’re defined somewhere."}]},{type:a,value:f},{type:b,tag:V,props:{id:dQ},children:[{type:b,tag:C,props:{href:"#function-parameters",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dR}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Some function will have parameters as part of the functions signature. When concrete values are passed (technically called arguments) those values are used within the function."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The declaration of "},{type:b,tag:i,props:{},children:[{type:a,value:aG}]},{type:a,value:" has one parameter named "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:". The type of "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" is specified as "},{type:b,tag:i,props:{},children:[{type:a,value:av}]},{type:a,value:". When 5 is passed to another_function, the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" macro puts 5 where the pair of curly brackets were in the format string."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In function signatures the type of argument a function should expect is required. This is a deliberate decision in Rust’s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When you want a function to have multiple parameters, separate the parameter declarations with commas, like so:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:bU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:V,props:{id:dS},children:[{type:b,tag:C,props:{href:"#function-bodies",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dT}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Function bodies are made up of a series of statements optionally ending in an expression. So far, we’ve only covered functions without an ending expression, but you have seen an expression as part of a statement. Because Rust is an expression-based language, this is an important distinction to understand. Other languages don’t have the same distinctions, so let’s look at what statements and expressions are and how their differences affect the bodies of functions."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:aL,props:{},children:[{type:a,value:"Statements"}]},{type:a,value:" are instructions that perform some action and do not return a value. "},{type:b,tag:aL,props:{},children:[{type:a,value:"Expressions"}]},{type:a,value:" evaluate to a resulting value."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Creating a variable and assigning a value to it with the "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" keyword is a statement. "},{type:b,tag:i,props:{},children:[{type:a,value:dW}]},{type:a,value:" is a statement."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bx},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Function definitions are also statements; the entire preceding example is a statement in itself."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Statements do not return values. Therefore, you can’t assign a let statement to another variable, as the following code tries to do; you’ll get an error:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bx},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When you run this program, the error you’ll get looks like this:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:dX},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:dY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"\nerror: expected expression, found statement "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bW},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:2:14\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"let y "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"              ^^^\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:" note: variable declaration using "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:" is a statement\n"}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:bH},{type:b,tag:i,props:{},children:[{type:a,value:"let y = 6"}]},{type:a,value:" statement does not return a value, so there isn’t anything for "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write "},{type:b,tag:i,props:{},children:[{type:a,value:"x = y = 6"}]},{type:a,value:" and have both "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:aR},{type:b,tag:i,props:{},children:[{type:a,value:bv}]},{type:a,value:" have the value 6; that is not the case in Rust."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Expressions evaluate to something and make up most of the rest of the code that you’ll write in Rust. Consider a simple math operation, such as "},{type:b,tag:i,props:{},children:[{type:a,value:"5 + 6"}]},{type:a,value:", which is an expression that evaluates to the value "},{type:b,tag:i,props:{},children:[{type:a,value:"11"}]},{type:a,value:". Expressions can be part of statements: below, the 6 in the statement "},{type:b,tag:i,props:{},children:[{type:a,value:dW}]},{type:a,value:" is an expression that evaluates to the value 6. Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, "},{type:b,tag:i,props:{},children:[{type:a,value:"{}"}]},{type:a,value:", is an expression, for example:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bx},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:"\n        x "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bj}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:bU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"take note of this block:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:by},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bj}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In this case, evaluates to "},{type:b,tag:i,props:{},children:[{type:a,value:aF}]},{type:a,value:". That value gets bound to y as part of the let statement. Note the "},{type:b,tag:i,props:{},children:[{type:a,value:dZ}]},{type:a,value:" line without a semicolon at the end, which is unlike most of the lines you’ve seen so far. Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value."}]},{type:a,value:f},{type:b,tag:V,props:{id:dU},children:[{type:b,tag:C,props:{href:"#functions-with-return-values",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:dV}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Functions can return values to the code that calls them. Return types are not named, but their values are declared using the an arrow "},{type:b,tag:i,props:{},children:[{type:a,value:bX}]},{type:a,value:". In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function. You can return from a function early by using the "},{type:b,tag:i,props:{},children:[{type:a,value:d_}]},{type:a,value:" keyword and specifying a value. Most functions however return the last expression implicitly. For example:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:bz}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bX}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:bz}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"There are no function calls, macros, or even "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" statements in the "},{type:b,tag:i,props:{},children:[{type:a,value:bz}]},{type:a,value:" function—just the number "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:" by itself. Which is a perfectly valid function in Rust. Note that the functions return type is specified as "},{type:b,tag:i,props:{},children:[{type:a,value:"-\u003E i32"}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:bH},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:" in "},{type:b,tag:i,props:{},children:[{type:a,value:bz}]},{type:a,value:" is the function’s return value, which is why the return type is "},{type:b,tag:i,props:{},children:[{type:a,value:av}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Another example:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:d$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:d$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bX}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:av}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:by},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bj}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Running this code will print "},{type:b,tag:i,props:{},children:[{type:a,value:"The value of x is: 6"}]},{type:a,value:". But if we place a semicolon at the end of the line containing "},{type:b,tag:i,props:{},children:[{type:a,value:dZ}]},{type:a,value:", changing it from an expression to a statement, we’ll get an error."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:dX},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:dY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:ea},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:eb},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:7:24\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"7"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" fn plus_one"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"x: i32"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:" -"},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" i32 "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"    --------            ^^^ expected "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:ec},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"    implicitly returns "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:" as its body has no "},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"tail"}]},{type:a,value:br},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:d_}]},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:" expression\n"},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:dx}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"     x + "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"          - help: consider removing this semicolon\n\nerror: aborting due to previous error\n\nFor "},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:bf}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:ed},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"functions"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:aX}]},{type:a,value:bw}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The main error message, “mismatched types,” reveals the core issue with this code. The definition of the function plus_one says that it will return an i32, but statements don’t evaluate to a value, which is expressed by (), an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error."}]}]},dir:aI,path:"\u002Fblog\u002Frust-functions",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"rust-ownership",title:"ownership in rust",date:"2021-01-03T08:11",desc:ba,tags:[aN],toc:[{id:ee,depth:U,text:ef},{id:eg,depth:U,text:eh},{id:ei,depth:U,text:ej},{id:ek,depth:U,text:el},{id:em,depth:U,text:en}],body:{type:aH,children:[{type:b,tag:j,props:{},children:[{type:a,value:"Rust’s central feature is ownership. Although the feature is straightforward to explain, it has deep implications for the rest of the language."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running."}]},{type:a,value:f},{type:b,tag:V,props:{id:ee},children:[{type:b,tag:C,props:{href:"#the-stack-and-the-heap",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:ef}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In many programming languages, you don’t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as "},{type:b,tag:aL,props:{},children:[{type:a,value:"last in"}]},{type:a,value:aK},{type:b,tag:aL,props:{},children:[{type:a,value:"first out"}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses."}]},{type:a,value:f},{type:b,tag:V,props:{id:eg},children:[{type:b,tag:C,props:{href:"#ownership-rules",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:eh}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Here are the three rules of ownership in Rust:"}]},{type:a,value:f},{type:b,tag:bi,props:{},children:[{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"Each value in Rust has a variable that's called its owner."}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"There can only be one owner at a time."}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"When the owner goes out of scope, the value will be dropped."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:V,props:{id:ei},children:[{type:b,tag:C,props:{href:"#variable-scope",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:ej}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As a first example of ownership, we’ll look at the scope of some variables. A scope is the range within a program for which an item is valid. Let’s say we have a variable that looks like this:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The variable "},{type:b,tag:i,props:{},children:[{type:a,value:bl}]},{type:a,value:" refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it’s declared until the end of the current scope."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:a,value:aZ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:eo},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F s is not valid here, it’s not yet declared"}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:ep}]},{type:a,value:bJ},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:eq}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:eo},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F this scope is now over, and s is no longer valid"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In other words, there are two important points in time here:"}]},{type:a,value:f},{type:b,tag:bi,props:{},children:[{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"When "},{type:b,tag:i,props:{},children:[{type:a,value:bl}]},{type:a,value:" come into scope and is therefore valid."}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"It remains valid until it goes out of scope."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we’ll build on top of this understanding by introducing the "},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:" type."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The types covered "},{type:b,tag:C,props:{href:"..\u002Frust-data-types.md"},children:[{type:a,value:"previously"}]},{type:a,value:" are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"String literals are immutable which may not be suitable for every situation. Also, not every string value can be known at author time (think user input). For these scenarios Rust has a second string type, "},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:". This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a "},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:" from a string literal using the "},{type:b,tag:i,props:{},children:[{type:a,value:a_}]},{type:a,value:" function, like so:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bm}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This kind of string can be mutated:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ay}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bm}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:"\ns"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"push_str"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\", world!\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F push_str() appends a literal to a String"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:"\"{}\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:" s"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F This will print `hello, world!`"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"So, what’s the difference here? Why can "},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:" be mutated but literals cannot? The difference is how these two types deal with memory."}]},{type:a,value:f},{type:b,tag:V,props:{id:ek},children:[{type:b,tag:C,props:{href:"#memory-and-allocation",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:el}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal’s immutability. Unfortunately, we can’t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"With the "},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:" type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:"}]},{type:a,value:f},{type:b,tag:bi,props:{},children:[{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"The memory must be requested from the memory allocator at runtime."}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"We need a way of returning this memory to the allocator when we’re done with our String."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"That first part is done by us: when we call "},{type:b,tag:i,props:{},children:[{type:a,value:"String::from"}]},{type:a,value:", its implementation requests the memory it needs. This is pretty much universal in programming languages."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"However, the second part is different. In languages with a "},{type:b,tag:aL,props:{},children:[{type:a,value:"garbage collector"}]},{type:a,value:" (GC), the GC keeps track and cleans up memory that isn’t being used anymore, and we don’t need to think about it."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Without a GC, it’s our responsibility to identify when memory is no longer being used and call code to explicitly return it,just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget,we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. We need to pair exactly one "},{type:b,tag:i,props:{},children:[{type:a,value:"allocate"}]},{type:a,value:" with exactly one "},{type:b,tag:i,props:{},children:[{type:a,value:"free"}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:a,value:aZ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bm}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:ep}]},{type:a,value:bJ},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:eq}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:"                                  "},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F this scope is now over, and s is no"}]},{type:a,value:"\n                                       "},{type:b,tag:c,props:{className:[d,$]},children:[{type:a,value:"\u002F\u002F longer valid"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"There is a natural point at which we can return the memory our String needs to the allocator: when "},{type:b,tag:i,props:{},children:[{type:a,value:bl}]},{type:a,value:" goes out of scope.\nRust calls a special function called "},{type:b,tag:i,props:{},children:[{type:a,value:er}]},{type:a,value:" when a variable goes out of scope. This style similar to "},{type:b,tag:C,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FResource_acquisition_is_initialization",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"Resource Acquisition Is Initialization"}]},{type:a,value:" in C++,has a huge impact on the way Rust code is authored."}]},{type:a,value:f},{type:b,tag:V,props:{id:em},children:[{type:b,tag:C,props:{href:"#ways-variables-and-data-interact-move",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:en}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Multiple variables can interact with the same data in different ways in Rust."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bx},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"We can probably guess what this is doing: bind the value "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:bt},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:"; then make a copy of the value in "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:es},{type:b,tag:i,props:{},children:[{type:a,value:bv}]},{type:a,value:".We now have two variables, "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:aR},{type:b,tag:i,props:{},children:[{type:a,value:bv}]},{type:a,value:", and both equal "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:". This is indeed what is happening, because integers are simple values with a known, fixed size, and these two "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:" values are pushed onto the stack."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:a,value:aZ},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bY},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bm}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bZ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:bA},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The above code on the surface looks very similar to the previous example. It would be easy to assume that the way it works would be the same: that is, the second line would make a copy of the value in "},{type:b,tag:i,props:{},children:[{type:a,value:a$}]},{type:a,value:es},{type:b,tag:i,props:{},children:[{type:a,value:bB}]},{type:a,value:". But this isn’t quite what happens."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:bE},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:" is made up of three parts, shown on the left: a "},{type:b,tag:i,props:{},children:[{type:a,value:"pointer"}]},{type:a,value:" to the memory that holds the contents of the string, a "},{type:b,tag:i,props:{},children:[{type:a,value:"length"}]},{type:a,value:", and a "},{type:b,tag:i,props:{},children:[{type:a,value:"capacity"}]},{type:a,value:". This group of data is stored on the stack. On the right is the memory on the heap that holds the contents."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The length is how much memory, in bytes, the contents of the "},{type:b,tag:i,props:{},children:[{type:a,value:aw}]},{type:a,value:" is currently using. The capacity is the total amount of memory, in bytes, that the String has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it’s fine to ignore the capacity."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When we assign "},{type:b,tag:i,props:{},children:[{type:a,value:a$}]},{type:a,value:bt},{type:b,tag:i,props:{},children:[{type:a,value:bB}]},{type:a,value:", the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust does not copy the data, it would be extremely expensive in terms of runtime performance if the data on the heap grows unchecked."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust automatically calls the "},{type:b,tag:i,props:{},children:[{type:a,value:er}]},{type:a,value:" function and cleans up the heap memory for that variable. So what would happen if there was a two pointers to the same place in memory. When both the variables goes out of scope the same place in memory will tried to be freed up. This is a problem: when "},{type:b,tag:i,props:{},children:[{type:a,value:bB}]},{type:a,value:aR},{type:b,tag:i,props:{},children:[{type:a,value:a$}]},{type:a,value:" go out of scope, they will both try to free the same memory. This is known as a double free error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"To ensure memory safety, there’s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers s1 to no longer be valid and, therefore, Rust doesn’t need to free anything when s1 goes out of scope. Check out what happens when you try to use "},{type:b,tag:i,props:{},children:[{type:a,value:a$}]},{type:a,value:" after "},{type:b,tag:i,props:{},children:[{type:a,value:bB}]},{type:a,value:" is created; it won’t work:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:a,value:aZ},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bY},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bm}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:bZ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:bA},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:et}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:bA},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You’ll get an error like this because Rust prevents you from using the invalidated reference:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:"$ cargo run\n   Compiling ownership v0.1.0 "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"file:\u002F\u002F\u002Fprojects\u002Fownership"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:"E0382"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:": borrow of moved value: "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:a$},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:bW},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:5:28\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:a,value:bY},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:" String::from"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"         -- move occurs because "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:a$},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:" has "},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:bP}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"std::string::String"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"which"}]},{type:a,value:" does not implement the "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"Copy"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:" trait\n"},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:a,value:bZ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:bA},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"              -- value moved here\n"},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:" \n"},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:eu},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:et}]},{type:a,value:", s1"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"                            ^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor "},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:bf}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"rustc --explain E0382"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"ownership"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:aX}]},{type:a,value:bw}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"If you’ve heard the terms (shallow copy)[https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FObject_copying#Shallow_copy] and (deep copy)[https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FObject_copying#Deep_copy] while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"There’s a design choice that’s implied by this: Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance."}]}]},dir:aI,path:"\u002Fblog\u002Frust-ownership",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"rust-variables-and-mutability",title:"variables and mutability in rust",date:"2020-12-11T11:02",desc:ba,tags:[aN],toc:[{id:ev,depth:aC,text:ew},{id:ex,depth:aC,text:ey},{id:ez,depth:aC,text:eA}],body:{type:aH,children:[{type:b,tag:aD,props:{id:ev},children:[{type:b,tag:C,props:{href:"#first-steps",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:ew}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Variables in rust are "},{type:b,tag:C,props:{href:"https:\u002F\u002Fwww.dictionary.com\u002Fbrowse\u002Fimmutable",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"immutable"}]},{type:a,value:" by default. a helpful hint by the language to write code that is easy to follow and avoid any unwanted side effects are reduced."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Once a immutable variable is bound to a name, it cannot change. Let's have a quick look at what that means."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:by},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The above code will not compile. We are trying to change the value of "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" from 5 to 6. The compiler will complain pretty loudly in fact."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:bC},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:"E0384"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:": cannot assign twice to immutable variable "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:bW},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:4:5\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"         -\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"         "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"         first assignment to "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"         help: "},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"make"}]},{type:a,value:" this binding mutable: "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"mut x"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:eu},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:a,value:", x"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aF}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"     x "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"     ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor "},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:bf}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:"rustc --explain E0384"},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:eB},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:aX}]},{type:a,value:dv}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This is a good thing, the compiler is nudging you to solving the issue at hand. Take note of the following message: "},{type:b,tag:i,props:{},children:[{type:a,value:"cannot assign twice to immutable variable x"}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Now we know we have two options to achieve the desired output. We can either create a new immutable variable and assign "},{type:b,tag:i,props:{},children:[{type:a,value:at}]},{type:a,value:" to it. Or, we can make "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" mutable. If we want to make "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" mutable we can add the "},{type:b,tag:i,props:{},children:[{type:a,value:ay}]},{type:a,value:" keyword to the variable declaration."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ay}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:by},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"We can now run the program"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:bC},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:eC},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:eD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:eE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bl},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bq}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:a,value:".30s\n     Running "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:eF},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:b_},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:a,value:b_},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:at}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In some cases, you’ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"There are always going to be trade offs when choosing to make things immutable or mutable. For instance if the data structure was particularly large it may make sense to mutate in place rather than save a copy and re-allocate the data. With small data it may make sense to create new instances of the data and writing it in a more functional style, the drop in performance may a price worth paying for legibility."}]},{type:a,value:f},{type:b,tag:aD,props:{id:ex},children:[{type:b,tag:C,props:{href:"#variables-vs-constants",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:ey}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Having an immutable variable may sound like that variable is really a constant. However in rust constants cannot be marked as mutable using "},{type:b,tag:i,props:{},children:[{type:a,value:ay}]},{type:a,value:". They are always immutable."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You declare constants using the "},{type:b,tag:i,props:{},children:[{type:a,value:eG}]},{type:a,value:" keyword instead of let as you would with a variable. You also must annotate a type. They can be declared in any scope including the global scope which makes them useful for values that many parts of code need to know about."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Below is how you would declare a constant for "},{type:b,tag:i,props:{},children:[{type:a,value:eH}]},{type:a,value:" with a value set to 100,000."}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:eG}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,"constant"]},children:[{type:a,value:eH}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:au}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:dr}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"100_000"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Constants stick around for the entire time a program runs within the scope in which it is declared. These values are the non-changing hardcoded values like "},{type:b,tag:i,props:{},children:[{type:a,value:"SPEED_OF_SOUND"}]},{type:a,value:br},{type:b,tag:i,props:{},children:[{type:a,value:"HOURS_IN_DAY"}]},{type:a,value:". They let maintainers know that these values are intentionally hardcoded. It also allows these values to be changed in one place, should they need to be updated in the future."}]},{type:a,value:f},{type:b,tag:aD,props:{id:ez},children:[{type:b,tag:C,props:{href:"#shadowing",ariaHidden:G,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:eA}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. The first variable is "},{type:b,tag:aL,props:{},children:[{type:a,value:"shadowed"}]},{type:a,value:" by the second. This means the second variables value is what appears when the variable is used. A quick example:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:i,props:{},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:K}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L,A]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:S}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bj}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,Q,R]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This program first binds "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" to a value of "},{type:b,tag:i,props:{},children:[{type:a,value:S}]},{type:a,value:". Then it shadows "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" by repeating "},{type:b,tag:i,props:{},children:[{type:a,value:"let x ="}]},{type:a,value:", taking the original value and adding "},{type:b,tag:i,props:{},children:[{type:a,value:Y}]},{type:a,value:" so the value of "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" is then "},{type:b,tag:i,props:{},children:[{type:a,value:at}]},{type:a,value:". The third let statement also shadows "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:", multiplying the previous value by "},{type:b,tag:i,props:{},children:[{type:a,value:ak}]},{type:a,value:" to give "},{type:b,tag:i,props:{},children:[{type:a,value:X}]},{type:a,value:" a final value of "},{type:b,tag:i,props:{},children:[{type:a,value:bV}]},{type:a,value:". When we run this program, it will output the following:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:bC},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:eC},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:eD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:eE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bl},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:bq}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ax}]},{type:a,value:".31s\n     Running "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:eF},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:b_},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:bV}]},{type:a,value:ap}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Shadowing is different from marking a variable as "},{type:b,tag:i,props:{},children:[{type:a,value:ay}]},{type:a,value:". We would get a compile-time error\nif we accidentally try to reassign to this variable without using the "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" keyword. Using "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" we can perform transformations on a value but have the variable be immutable after those transformations have occurred."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The other difference between "},{type:b,tag:i,props:{},children:[{type:a,value:ay}]},{type:a,value:" and shadowing is that because we’re effectively creating a new variable when we use the "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:b$},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:eI}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:b$},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:eJ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:eK}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This is valid as we use the keyword "},{type:b,tag:i,props:{},children:[{type:a,value:r}]},{type:a,value:" which ensures the second "},{type:b,tag:i,props:{},children:[{type:a,value:"spaces"}]},{type:a,value:" is a brand new variable. This saves us the need to come up with new names for each assignment, like "},{type:b,tag:i,props:{},children:[{type:a,value:"spaces_str"}]},{type:a,value:br},{type:b,tag:i,props:{},children:[{type:a,value:"spaces_num"}]},{type:a,value:". Note that using "},{type:b,tag:i,props:{},children:[{type:a,value:ay}]},{type:a,value:" will not achieve the desired outcome:"}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,F]},children:[{type:b,tag:i,props:{},children:[{type:a,value:aZ},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ay}]},{type:a,value:b$},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:eI}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:"\n    spaces "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:eJ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:eK}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:w,props:{className:[x]},children:[{type:b,tag:y,props:{className:[z,aj]},children:[{type:b,tag:i,props:{},children:[{type:a,value:bC},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:Z}]},{type:a,value:ea},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:_}]},{type:a,value:eb},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:as}]},{type:a,value:" src\u002Fmain.rs:3:14\n  "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ag}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"     spaces "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:s}]},{type:a,value:" spaces.len"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:m}]},{type:a,value:"              ^^^^^^^^^^^^ expected "},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:dO}]},{type:a,value:dP},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:ec},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:dy},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:a,value:du},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:bf}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:ed},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,q]},children:[{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]},{type:a,value:eB},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:B}]}]},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:W}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,T,N]},children:[{type:a,value:aX}]},{type:a,value:bw}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"I'll be looking at data types next"}]}]},dir:aI,path:"\u002Fblog\u002Frust-variables-and-mutability",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"thinking-out-loud",title:"thinking out loud",date:"2020-11-30T08:52",desc:"Some thoughts and ideas as I begin to write again",tags:[eL],toc:[],body:{type:aH,children:[{type:b,tag:j,props:{},children:[{type:a,value:"It's been a while since I wrote some things down, my focus has shifted and I have my eye on new topics and ideas."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Day to day going through major growth in my day job, the last 18 months or so have changed me as a professional dramatically."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Next areas of focus:"}]},{type:a,value:f},{type:b,tag:bi,props:{},children:[{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"AWS serverless architecture"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"3D theory"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"System design"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"Rust & WASM"}]},{type:a,value:f},{type:b,tag:ai,props:{},children:[{type:a,value:"Testing"}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This areas of focus are going to be my main focus for the next few months, by writing them down I hope I can be a little more accountable for what I am learning and writing about. I would like to continue to explore some additional ideas using JS, TS and Node. I have a strong competency in JavaScript and I would like to continue on that path to mastery."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Short and sweet."}]}]},dir:aI,path:"\u002Fblog\u002Fthinking-out-loud",extension:aJ,createdAt:ah,updatedAt:ah},{slug:"why-rust",title:"why rust",date:"2020-12-08T06:52",desc:"There is something drawing me down into the system, closer to the metal. As someone who has spent the majority of their time up in the clouds of abstraction (JavaScript) learning a language closer to the machine has its appeal.",tags:[aN,eL],toc:[],body:{type:aH,children:[{type:b,tag:j,props:{},children:[{type:a,value:"There is something drawing me down towards the bits, closer to the metal. As someone who has spent the majority of their career up in the clouds of abstraction (JavaScript) learning a language closer to the machine has it's appeal. "},{type:b,tag:C,props:{href:"https:\u002F\u002Fwebassembly.org\u002F",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"WASM"}]},{type:a,value:" is knocking at the door of the modern browser and Rust seems to gel well with next this chapter in browser performance."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Rust's "},{type:b,tag:C,props:{href:"https:\u002F\u002Finsights.stackoverflow.com\u002Fsurvey\u002F2020#technology-most-loved-dreaded-and-wanted-languages-loved",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"soaring popularity"}]},{type:a,value:" has been hard to ignore. Some early experiments with the language and the "},{type:b,tag:C,props:{href:"https:\u002F\u002Fgithub.com\u002Frust-lang\u002Frls",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"Rust Language Server"}]},{type:a,value:" in VSCode have pushed me beyond dipping my toes to wading out a little further."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"There seems to be a focus on "},{type:b,tag:C,props:{href:"https:\u002F\u002Ftwitter.com\u002Fmahemoff\u002Fstatus\u002F1947230411948032",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"DX (Developer Experience)"}]},{type:a,value:" and ease of use."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The core tenants of performance, reliability and productivity certainly resonate. I want things to be fast, consistent and I want to be able to get them done in a timely manner. Plus all that memory and thread safety appeal to a naive JS dev like myself. Rust also has (great documentation)[https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Findex.html] and (vibrant community)[https:\u002F\u002Fwww.rust-lang.org\u002Fcommunity]."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Worst case scenario I learn a new language and maybe a few concepts I can bring into my daily work. I plan on going through the basics into data structures and algos over the next few months posting about my "},{type:b,tag:C,props:{href:"https:\u002F\u002Fwww.swyx.io\u002Flearn-in-public\u002F",rel:[ab,ac,ad],target:ae},children:[{type:a,value:"learnings and discoveries in public"}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Keeping these short and to the point as I shift through the gears of writing again. Looking forward to starting the next phase, onwards and upwards!"}]}]},dir:aI,path:"\u002Fblog\u002Fwhy-rust",extension:aJ,createdAt:ah,updatedAt:ah}]}],fetch:[],mutations:void 0}}("text","element","span","token","punctuation","\n"," ","operator","code","p","keyword","number","|",";","(",")","variable","let","=",",","string","\n    ","div","nuxt-content-highlight","pre","line-numbers","function","`","a","{","}","language-rust","true",-1,"icon","icon-link","fn","function-definition","main","class-name","println!","\n\n    ","macro","property","5","builtin",3,"h3",".","x","1","[","]","comment","\n  ","nofollow","noopener","noreferrer","_blank"," x ","3","2021-01-08T17:06:58.039Z","li","language-bash","2","\n        ","if","src\u002Fmain.rs","!","\n\n"," x","  ","\u003E","6",":","i32","String","0","mut","       "," number ","\"The value of x is: {}\"",2,"h2","else","4","another_function","root","\u002Fblog",".md",", ","strong","\"hello\"","rust","   ","10"," a "," and ","loop","break"," a","     ","\n\nTo learn more, run the ","command"," y","    ","from","s1","A look at basic building blocks of rust","boolean","while","for","\nerror","more"," information about this error, try ","\nerror: could not compile ","ul","+"," s ","s","::","%","==",", and ","in"," or ","char"," to ","6.4","y"," again with --verbose.\n"," y ","\n    x ","five"," s1","s2","$ cargo run\n   Compiling variables v0.1.0 ","file:\u002F\u002F\u002Fprojects\u002Fvariables","A "," NEXT  "," number","The "," counter ","\n\n        ","*","30"," index ","index"," element ","type","-bit ","f32","f64","500","\"The value of y is: {}\"","12","\n --","-\u003E"," s1 "," s2 ","\nThe value of x is: "," spaces ","singly linked list","The world is swarming in lists, to-dos, shopping, sprint backlogs. Linear in nature they help us mere mortals keep track of things and their relationships to each other. Having a re-visit to this fundamental data structure with the help of Rust.","linked-lists","Linked Lists","example","Example","pros","Pros","cons","Cons","doubly-linked-lists","Doubly Linked Lists","skip-lists","Skip Lists","\n+--------+  ","----------","------------","if-expressions","if Expressions","handling-multiple-conditions-with-else-if","Handling Multiple Conditions with else if","using-if-in-a-let-statement","Using if in a let Statement","repetition-with-loops","Repetition with Loops","returning-values-from-loops","Returning Values from Loops","conditional-loops-with-while","Conditional Loops with while","looping-through-a-collection-with-for","Looping Through a Collection with for","\u003C","bool"," condition ","It’s often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs. When the condition ceases to be true, the program calls ","+=","result","\"{}!\"","\"LIFT OFF!!!\"","\nLIFT OFF","20","40","50","\"the value is: {}\""," element","rev","data-types","Data Types","scalar-types","Scalar Types","integer","Integer","integer-literals","Integer Literals","floating-point-types","Floating-Point Types","numeric-operations","Numeric Operations","Boolean","character-type","Character Type","compound-types","Compound Types","tuple-type","Tuple Type","array-type","Array Type","accessing-array-elements","Accessing Array Elements","invalid-array-element-access","Invalid Array Element Access","u32","\"42\"","\"Not a number!\"","\n\nerror: aborting due to previous error\n\nFor "," again with --verbose.\n\n","--------","8","usize"," tup","u8","\"January\"","\"February\"","\"March\"","\"April\"","\"May\"","\"June\"","\"July\"","\n              ","\"August\"","\"September\"","\"October\"","\"November\"","\"December\"","&","str","function-parameters","Function Parameters","function-bodies","Function Bodies","functions-with-return-values","Functions with Return Values","let y = 6;","$ cargo run\n   Compiling functions v0.1.0 ","file:\u002F\u002F\u002Fprojects\u002Ffunctions","x + 1","return","plus_one","E0308",": mismatched types\n --",", found ","rustc --explain E0308","the-stack-and-the-heap","The Stack and the Heap","ownership-rules","Ownership Rules","variable-scope","Variable Scope","memory-and-allocation","Memory and Allocation","ways-variables-and-data-interact-move","Ways Variables and Data Interact: Move","                      ","\u002F\u002F s is valid from this point forward","\u002F\u002F do stuff with s","drop"," and bind it to ","\"{}, world!\"","     println","first-steps","First Steps","variables-vs-constants","Variables vs Constants","shadowing","Shadowing","variables","\n    Finished dev ","unoptimized + debuginfo"," target","target\u002Fdebug\u002Fvariables","const","MAX","\"   \""," spaces","len","meta")));